/* Plugin Template generated by Pawn Studio */

#pragma semicolon 1

#include <sourcemod>
#include "dbi.inc"

// Make the admin menu plugin optional
#undef REQUIRE_PLUGIN
#include <adminmenu>

public Plugin:myinfo = 
{
	name = "Watchlist",
	author = "Recon",
	description = "Watchlist that admins can add suspicious players to.",
	version = "0.1",
	url = "http://forums.alliedmods.net/showthread.php?p=588456"
}

// Watchlist database
new Handle:Database = INVALID_HANDLE;

// Watchlist timer
new Handle:WatchlistPrint = INVALID_HANDLE;

// CVAR watch_announce_interval
new Handle:cvar_watch_announce_interval = INVALID_HANDLE;

// Handle to the admin menu
new Handle:hTopMenu = INVALID_HANDLE;

new targets[MAXPLAYERS];


/***************************** Forwards *****************************/

public OnPluginStart()
{
	
	// Connect to the DB
	SQL_TConnect(GotDatabase, "watchlist");
	
	// Create admin commands
	RegAdminCmd("sm_add_watch", Command_Add_Watch, ADMFLAG_GENERIC,
				"sm_add_watch steam_id | #userid \"reason\"",
				"Adds a player to the watchlist. If the client \
				is already on the list, the old entry will be overwritten.");
				
	RegAdminCmd("sm_remove_watch", Command_Remove_Watch, ADMFLAG_GENERIC,
				"sm_remove_watch steam_id | #userid",
				"Removes a player from the watchlist.");
				
	RegAdminCmd("sm_print_watch", Command_Print_Watch, ADMFLAG_GENERIC,
				"Prints the players on the server that are on the watchlist.");
				
					
	// Timer to output clients
	// on the watchlist every 5 minutes
	WatchlistPrint = CreateTimer(300.0, ShowWatch,
								INVALID_HANDLE,	TIMER_REPEAT);
	
	// Create our cvars
	cvar_watch_announce_interval = CreateConVar("watch_announce_interval", "5.0",
												"Controls how often users on the watchlist \
												who are currently on the server are announced. \
												The time is specified in whole minutes (1.0...10.0).",
												FCVAR_NONE,	true, 1.0, true, 10.0);
	
	// Every time the user changes our
	// convar, update the timer with the latest interval
	HookConVarChange(cvar_watch_announce_interval, OnWatchAnnounceIntervalChange);
	
}



public OnAllPluginsLoaded() {
	
	new Handle:topmenu;
	
	// Attach ourselves to the admin menu system
	if (LibraryExists("adminmenu") && ((topmenu = GetAdminTopMenu()) != INVALID_HANDLE))
	{
		OnAdminMenuReady(topmenu);
		
	}	
	
}

public OnLibraryRemoved(const String:name[])
{
	// If the admin menu gets unloaded
	if (StrEqual(name, "adminmenu"))
	{
		hTopMenu = INVALID_HANDLE;
	}
}

public OnClientAuthorized(client, const String:auth[]) {
	
	// Check to see if the user is on the watch list	
	
	decl String:query[256];
	decl String:steam[25];
	
	// Quote the steam id
	SQL_QuoteString(Database, auth, steam, sizeof(steam));
	
	// Prepare the query
	Format(query, sizeof(query), "SELECT client, reason FROM player_watch WHERE steam = '%s'", steam);
	
	// Send the query
	SQL_TQuery(Database, T_CheckUser, query, client);
	
}

public OnClientDisconnect(client) {
	
	// Set the active column to 0 for this client
	// (if they aren't on the watchlist, nothing will
	// happen
	
	decl String:query[256];
	decl String:steam[25];
	decl String:quoted_steam[25];
	
	// Get the steam id
	GetClientAuthString(client, steam, sizeof(steam));
	
	// Quote the steam id
	SQL_QuoteString(Database, steam, quoted_steam, sizeof(quoted_steam));	
	
	// Prepare and send the query
	Format(query, sizeof(query), "UPDATE player_watch SET client = -1 WHERE steam = '%s'", quoted_steam);
	SQL_TQuery(Database, T_Generic, query);
	
}

public OnAdminMenuReady(Handle:topmenu)
{
	// Block us from being called twice
	if (topmenu == hTopMenu)
	{
		return;
	}
		
	// Save the Handle
	hTopMenu = topmenu;
	
	// Find the "Player Commands" category 
	new TopMenuObject:player_commands = FindTopMenuCategory(hTopMenu, ADMINMENU_PLAYERCOMMANDS);

	// Make sure that player commands isn't invalid
	if (player_commands != INVALID_TOPMENUOBJECT)
	{
		// For adding players to the watchlist
		AddToTopMenu(hTopMenu, "watchlist_add",
					 TopMenuObject_Item, mnuAddWatch,
					 player_commands, "sm_add_watch");	
					 
		
		// For removing players from the watchlist
		AddToTopMenu(hTopMenu, "watchlist_remove",
					 TopMenuObject_Item, mnuRemoveWatch,
					 player_commands, "sm_remove_watch");
		
	}
}

/***************************** Callbacks from forwards *****************************/

public T_CheckUser(Handle:owner, Handle:hndl, const String:error[], any:data) {
	
	if (hndl == INVALID_HANDLE) {
		LogError("[Watchlist] Query Failed: %s", error);
		return;
	}
	
	// If they're on the watchlist, set
	// their client index
	if (SQL_FetchRow(hndl)) {
		
		decl String:name[35];
		decl String:reason[513];
		decl String:steam[25];
		decl String:quoted_steam[51];
		
		decl String:query[256];
		
		// Get their name, steam and reason
		GetClientName(data, name, sizeof(name));
		GetClientAuthString(data, steam, sizeof(steam));
		SQL_FetchString(hndl, 1, reason, sizeof(reason));
		
		// Quote the steam id
		SQL_QuoteString(Database, steam, quoted_steam, sizeof(quoted_steam));
		
		// Set the client to active
		Format(query, sizeof(query), "UPDATE player_watch SET client = %i WHERE steam = '%s'", data, quoted_steam);
		SQL_TQuery(Database, T_Generic, query);
		
		// Output a message
		PrintToChatAll("[Watchlist] Player %s is on the watchlist for %s", name, reason);
	}
}

/***************************** Commands *****************************/

public Action:Command_Add_Watch (client, args) {
	
	decl String:player_id[25];
		
	decl String:steam[25];
	
	decl String:reason[256];
	
	
	// If someone uses userid, we need to
	// get their client
	new target = -1;
	
	if (GetCmdArgs() < 2) {
		ReplyToCommand(client, "You must provide both a (steamid or userid) AND a reason");
		return Plugin_Handled;
	}		
	
	// Get the player's userid or steam id
	GetCmdArg(1, player_id, sizeof(player_id));
	
	if (player_id[0] == '#') {
		
		target = GetClientOfUserId(StringToInt(player_id[1]));
		
		// Make sure the userid is valid
		if (target != 0)
			GetClientAuthString(client, steam, sizeof(steam));	
		
		else {
			ReplyToTargetError(client, COMMAND_TARGET_NOT_IN_GAME);
			return Plugin_Handled;
		}
	}
	else
		steam = player_id;
	
	// Get the reason
	GetCmdArg(2, reason, sizeof(reason));
	
	AddWatch(client, target, steam, reason);
	
	return Plugin_Handled;
	
}

public Action:Command_Remove_Watch (client, args) {
	
	decl String:player_id[25];
	
	decl String:steam[25];
	
	new target = -1;
	
	// Get the player's userid or steam id
	GetCmdArg(1, player_id, sizeof(player_id));
	
	if (player_id[0] == '#') {
		
		target= GetClientOfUserId(StringToInt(player_id[1]));
		
		// Make sure the userid is valid
		if (target != 0)
			GetClientAuthString(client, steam, sizeof(steam));	
		
		else {
			ReplyToTargetError(client, COMMAND_TARGET_NOT_IN_GAME);
			return Plugin_Handled;
		}
	}
	else
		steam = player_id;
	
	RemoveWatch(client, target, steam);
	
	return Plugin_Handled;
}

public Action:Command_Print_Watch (client, args) {

	PrintWatchList();
	return Plugin_Handled;
}

/***************************** Command functions *****************************/

AddWatch(client, target, String:steam[], String:reason[]) {
	
	decl String:quoted_steam[51];
	
	decl String:quoted_reason[513];
	
	decl String:query[512];
	
	// Quote the steam id
	SQL_QuoteString(Database, steam, quoted_steam, sizeof(quoted_steam));

	// Quote the reason
	SQL_QuoteString(Database, reason, quoted_reason, sizeof(quoted_reason));
	
	// Insert the watch
	Format(query, sizeof(query), "INSERT INTO player_watch (client, steam, reason) VALUES (%i, '%s', '%s')",
								  target, quoted_steam, quoted_reason);
	SQL_TQuery(Database, T_AddWatch, query, client);
		
	// Let everyone know what happened
	if (target > 0) {
		decl String:player_name[35];
		
		GetClientName(target, player_name, sizeof(player_name));
		
		PrintToChatAll("[Watchlist] Added player %s to the watchlist for %s", player_name, reason);
	}
	
	// Log the action
	LogAction(client, target, "Added player %s to the watchlist for %s", steam, reason);
	
}

RemoveWatch(client, target, String:steam[]) {
	
	decl String:quoted_steam[51];
	
	decl String:query[256];
	
	// Quote the steam
	SQL_QuoteString(Database, steam, quoted_steam, sizeof(quoted_steam));
	
	// Prepare and send the query
	Format(query, sizeof(query), "DELETE FROM player_watch WHERE steam = '%s'", quoted_steam);	
	SQL_TQuery(Database, T_RemoveWatch, query, client);	
	
	// Log the action
	LogAction(client, target, "Removed player %s from the watchlist", steam);
	
}

/***************************** Command function callbacks *****************************/

public T_AddWatch(Handle:owner, Handle:hndl, const String:error[], any:data) {
	
	if (hndl == INVALID_HANDLE) {
		LogError("[Watchlist] Query Failed: %s", error);
		PrintToChat(data, "Unable to add watch: %s", error);		
	}
	else {
		// Log to be relocated here
	}
	
}

public T_RemoveWatch(Handle:owner, Handle:hndl, const String:error[], any:data) {
	
	if (hndl == INVALID_HANDLE) {
		LogError("[Watchlist] Query Failed: %s", error);
		PrintToChat(data, "Unable to remove watch: %s", error);
		
	}
	else {
		PrintToChat(data, "[Watchlist] Removed player from watchlist.");
	}
	
	
}

/***************************** WatchlistPrint Timer Methods *****************************/

public OnWatchAnnounceIntervalChange(Handle:cvar, const String:oldVal[], const String:newVal[]) {
	
	// Close the old timer
	CloseHandle(WatchlistPrint);
	
	// Create a new timer
	WatchlistPrint = CreateTimer(StringToInt(newVal) * 60.0, ShowWatch,
								 INVALID_HANDLE, TIMER_REPEAT);
	
}

public Action:ShowWatch(Handle:timer, Handle:pack)
{
	
	PrintWatchList();
	
}

PrintWatchList() {
	
	SQL_TQuery(Database, T_ShowWatch, "SELECT * FROM player_watch WHERE client > 0");
	
}

public T_ShowWatch(Handle:owner, Handle:hndl, const String:error[], any:data) {
	
	if (hndl == INVALID_HANDLE) {
		LogError("[Watchlist] Query Failed: %s", error);
		return;
	}
	
	while (SQL_FetchRow(hndl)) {
	
		decl String:steam[25];
		decl String:ingame_steam[25];
		
		decl client;
		
		// Get the client index
		client = SQL_FetchInt(hndl, 0);
		
		// Get the steam from the database
		SQL_FetchString(hndl, 1, steam, sizeof(steam));
		
		// Get the client's steam id by index
		GetClientAuthString(client, ingame_steam, sizeof(ingame_steam));
		
		// Make sure this client is valid
		if (strcmp(steam, ingame_steam) == 0) {
			
			decl String:name[35];
			decl String:reason[256];
			
			// Get the reason
			SQL_FetchString(hndl, 2, reason, sizeof(reason));
			
			// Get the client name
			GetClientName(client, name, sizeof(name));
			
			// Output the message
			PrintToChatAll("[Watchlist] Player %s is on the watchlist for %s", name, reason);
		}
		
		// If not, invalidate the client
		else {
			
			decl String:query[256];
			decl String:quoted_steam[51];
			
			// Quote the steam id
			SQL_QuoteString(Database, steam, quoted_steam, sizeof(quoted_steam));	
	
			// Prepare and send the query
			Format(query, sizeof(query), "UPDATE player_watch SET client = -1 WHERE steam = '%s'", quoted_steam);
			SQL_TQuery(Database, T_Generic, query);			
		}			
	
	}
	
}

/***************************** Menu Methods *****************************/

public mnuAddWatch(Handle:topmenu, TopMenuAction:action,
					 TopMenuObject:object_id, param,		         
					 String:buffer[], maxlength)
{
	// If the menu is only being displayed, we'll just show the
	// option
	if (action == TopMenuAction_DisplayOption)	
	{
		// Show the menu option
		Format(buffer, maxlength, "Add player to watchlist", param);
		
	}
	else if (action == TopMenuAction_SelectOption)
	{
		// Someone wants to add someone to the watchlist,
		// so we'll show them a menu of everyone on the
		// server
		DisplayAddWatchTargetMenu(param);
		
	}
}

DisplayAddWatchTargetMenu(client) {
	
	// Create a new menu and pass it the handler
	new Handle:menu = CreateMenu(mnuAddWatchTarget);
	
	// Title of our menu
	decl String:title[100];
	
	// Create the title of the menu
	Format(title, sizeof(title), "Add player to watchlist", client);
	
	// Set the title
	SetMenuTitle(menu, title);
		
	// Yes we want back / exit item
	SetMenuExitBackButton(menu, true);
	
	// Add targets to the menu
	AddTargetsToMenu(menu, client, false, false);
	
	// Show the menu to the client until they close it
	DisplayMenu(menu, client, MENU_TIME_FOREVER);
}

public mnuAddWatchTarget (Handle:menu, MenuAction:action, param1, param2) {
	
	// If the client wants to close the menu
	if (action == MenuAction_End)
	{
		CloseHandle(menu);
	}
	
	// If the client wants to cancel
	else if (action == MenuAction_Cancel)
	{
		// If the client wants to go back
		if (param2 == MenuCancel_ExitBack && hTopMenu != INVALID_HANDLE)
		{
			DisplayTopMenu(hTopMenu, param1, TopMenuPosition_LastCategory);
		}
	}
	
	// If the client wants to add someone to the watchlist
	else if (action == MenuAction_Select)
	{
		decl String:info[32], String:name[32];
		new userid, target;
		
		GetMenuItem(menu, param2, info, sizeof(info), _, name, sizeof(name));
		userid = StringToInt(info);

		if ((target = GetClientOfUserId(userid)) == 0)
		{
			PrintToChat(param1, "[Watchlist] Player no longer available");
		}
		else if (!CanUserTarget(param1, target))
		{
			PrintToChat(param1, "[Watchlist] Player no longer available");
		}
		else
		{	
			// Store the target
			targets[param1] = target;
			
			// Display the reason menu
			DisplayWatchReasonMenu(param1);
		}
	}
}

DisplayWatchReasonMenu(client) {
	
	new Handle:menu = CreateMenu(mnuAddWatchReason);
	
	decl String:title[100];
	Format(title, sizeof(title), "Add player to watchlist", client);
	SetMenuTitle(menu, title);
	SetMenuExitBackButton(menu, true);
	
	AddMenuItem(menu, "Cheating / Hacking", "Cheating / Hacking");
	AddMenuItem(menu, "Map Exploit", "Map Exploit");
	AddMenuItem(menu, "General Exploit", "General Exploit");
	AddMenuItem(menu, "Tking", "TKing");
	AddMenuItem(menu, "Breaking server rules", "Breaking server rules");
	
	DisplayMenu(menu, client, MENU_TIME_FOREVER);

}

public mnuAddWatchReason (Handle:menu, MenuAction:action, param1, param2) {
	
	// If the client wants to close the menu
	if (action == MenuAction_End)
	{		
		CloseHandle(menu);
	}
	
	// If the client wants to cancel
	else if (action == MenuAction_Cancel)
	{
		// If the client wants to go back
		if (param2 == MenuCancel_ExitBack && hTopMenu != INVALID_HANDLE)
		{
			DisplayTopMenu(hTopMenu, param1, TopMenuPosition_LastCategory);
		}
	}
	
	// The client has made a selection,
	// so add the target to the watchlist
	else if (action == MenuAction_Select)
	{
		decl String:reason[256];
		decl String:reason_name[256];
		
		decl String:steam[25];
		
		// Store the target locally
		new target = targets[param1];
		
		// Get the client's steam id
		GetClientAuthString(target, steam, sizeof(steam));
	
		// Get the reason
		GetMenuItem(menu, param2, reason, sizeof(reason), _, reason_name, sizeof(reason_name));
		
		// Add the watch
		AddWatch(param1, target, steam, reason_name);
	
	}	
	
}

public mnuRemoveWatch(Handle:topmenu, TopMenuAction:action,
					  TopMenuObject:object_id, param,		         
					  String:buffer[], maxlength)
{
	// If the menu is only being displayed, we'll just show the
	// option
	if (action == TopMenuAction_DisplayOption)	
	{
		// Show the menu option
		Format(buffer, maxlength, "Remove player from watchlist", param);
		
	}
	else if (action == TopMenuAction_SelectOption)
	{
		// Someone wants to add someone to the watchlist,
		// so we'll show them a menu of everyone on the
		// server
		DisplayRemoveWatchTargetMenu(param);
		
	}
}

DisplayRemoveWatchTargetMenu(client) {
	
	new Handle:menu = CreateMenu(mnuRemoveWatchTarget);
	
	decl String:title[100];
	Format(title, sizeof(title), "Remove player from watchlist", client);
	SetMenuTitle(menu, title);
	SetMenuExitBackButton(menu, true);
	
	// Pack up the menu and the client
	new Handle:pack = CreateDataPack();
	
	WritePackCell(pack, menu);
	WritePackCell(pack, client);
	
	// Query the database and get all active clients
	SQL_TQuery(Database, T_DisplayRemoveWatchTargetMenu, "SELECT * FROM player_watch WHERE client > 0", pack);
	
}

public T_DisplayRemoveWatchTargetMenu(Handle:owner, Handle:hndl, const String:error[], any:data) {
	
	if (hndl == INVALID_HANDLE) {
		LogError("[Watchlist] Query Failed: %s", error);
		return;
	}
	
	// Unpack the data we need
	ResetPack(data);
	
	new Handle:menu = ReadPackCell(data);
	new client = ReadPackCell(data);
	
	// Close the pack
	CloseHandle(data);
	
	new bool:noClients = true;
	
	while (SQL_FetchRow(hndl)) {
	
		decl String:steam[25];
		decl String:ingame_steam[25];
		decl String:target_s[10];
		
		// Get the client index
		new target = SQL_FetchInt(hndl, 0);
		
		IntToString(target, target_s, sizeof(target_s));
		
		// Get the steam from the database
		SQL_FetchString(hndl, 1, steam, sizeof(steam));
		
		// Get the client's steam id by index
		GetClientAuthString(target, ingame_steam, sizeof(ingame_steam));
		
		// Make sure this client is valid
		if (strcmp(steam, ingame_steam) == 0) {
			
			decl String:name[35];
			
			// Get the client name
			GetClientName(target, name, sizeof(name));
			
			// Add the client to the menu
			AddMenuItem(menu, target_s, name);
			
			if (noClients)
				noClients = false;
			
		}
		
		// If not, invalidate the client
		else {
			
			decl String:query[256];
			decl String:quoted_steam[51];
			
			// Quote the steam id
			SQL_QuoteString(Database, steam, quoted_steam, sizeof(quoted_steam));	
	
			// Prepare and send the query
			Format(query, sizeof(query), "UPDATE player_watch SET client = -1 WHERE steam = '%s'", quoted_steam);
			SQL_TQuery(Database, T_Generic, query);			
		}			
	
	}
	
	// Check to see if anyone is on the watchlist is on the server
	if (noClients) {
		AddMenuItem(menu, "noClients", "No one in the server is on the watchlist.");
		
	}
	
	// Finally, display the menu
	DisplayMenu(menu, client, MENU_TIME_FOREVER);
	
}

public mnuRemoveWatchTarget(Handle:menu, MenuAction:action, param1, param2) {
	
	// If the client wants to close the menu
	if (action == MenuAction_End)
	{		
		CloseHandle(menu);
	}
	
	// If the client wants to cancel
	else if (action == MenuAction_Cancel)
	{
		// If the client wants to go back
		if (param2 == MenuCancel_ExitBack && hTopMenu != INVALID_HANDLE)
		{
			DisplayTopMenu(hTopMenu, param1, TopMenuPosition_LastCategory);
		}
	}
	
	// The client has made a selection,
	// so add remove the target from the
	// watchlist
	else if (action == MenuAction_Select)
	{
		decl String:steam[25];
		decl String:target_s[15];
		decl String:junk[256];
		decl target;
		
		// Get the client index
		GetMenuItem(menu, param2, target_s, sizeof(target_s), _, junk, sizeof(junk));
		
		// If there aren't any active clients, and the
		// user selects our message, close the menu
		if (strcmp(target_s, "noClients", true) == 0) {
			return;			
		}
		
		// Convert the client index to an int
		target = StringToInt(target_s);
		
		// Get the client's steam id
		GetClientAuthString(target, steam, sizeof(steam));		
		
		// Remove the watch
		RemoveWatch(param1, target, steam);
	
	}	
	
}




/***************************** Database Init *****************************/

InitDB() {

	// Create the table
	new String:query[] ="CREATE TABLE IF NOT EXISTS player_watch ( \
						 client INTEGER NOT NULL,\
						 steam TEXT PRIMARY KEY ON CONFLICT REPLACE,\
						 reason TEXT NOT NULL);";						

	SQL_TQuery(Database, T_Generic, query);
	
}

/***************************** Threaded callbacks *****************************/


public T_Generic(Handle:owner, Handle:hndl, const String:error[], any:data) {
	
	if (hndl == INVALID_HANDLE)
		LogError("[Watchlist] Query Failed: %s", error);
	
}

// Callback when we have connected to the database
public GotDatabase(Handle:owner, Handle:hndl, const String:error[], any:data) {
	
	if (hndl == INVALID_HANDLE)
		LogError("[Watchlist] Could not connect to the DB: %s", error);
	else {
		Database = hndl;
		InitDB();
	}	
}